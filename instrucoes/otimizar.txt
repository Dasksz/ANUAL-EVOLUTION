1. O Grande Gargalo: O cálculo do "Mix" e JSONB
No seu arquivo sql/complete_system.sql, dentro da função get_main_dashboard_data, você executa isto:

SQL

CROSS JOIN jsonb_each_text(t.mix_details) p
...
HAVING SUM((p.value)::numeric) >= 1
O Problema: Isso é extremamente "caro" para o banco. Se você filtrar 1 ano de dados, o banco pega cada linha, explode o JSON do mix em várias linhas virtuais, converte texto para número e soma tudo na hora que o usuário clica.

A Solução: Mover esse cálculo matemático para a etapa de escrita (refresh_cache_summary). A tabela de resumo já deve conter o número pronto.

2. Bypass de RLS (Row Level Security)
Você tem RLS ativado na tabela data_summary. Quando você faz um SUM ou COUNT, o PostgreSQL verifica a permissão de cada linha individualmente antes de somar.

A Solução: Transformar a função get_main_dashboard_data em SECURITY DEFINER. Isso faz a função rodar com permissões de administrador (ignorando a verificação linha a linha do RLS), mas você deve garantir a segurança filtrando manualmente pelo parâmetro (filial/vendedor) dentro do WHERE.

Implementação Passo a Passo
Aqui está o código SQL para otimizar essas duas áreas.

Passo 1: Alterar a tabela de resumo para guardar os dados pré-calculados
Vamos adicionar colunas numéricas simples para não precisar abrir JSON na leitura.

SQL

-- Execute isso no Editor SQL do Supabase
ALTER TABLE public.data_summary 
ADD COLUMN IF NOT EXISTS pre_mix_count int DEFAULT 0,
ADD COLUMN IF NOT EXISTS pre_positivacao_val int DEFAULT 0; -- 1 se positivou, 0 se não
Passo 2: Otimizar a função de Refresh (refresh_cache_summary)
Esta função fará o trabalho pesado uma vez (quando os dados sobem), deixando a leitura instantânea. Substitua a função existente no seu arquivo sql/complete_system.sql por esta versão otimizada:

SQL

CREATE OR REPLACE FUNCTION refresh_cache_summary()
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
    SET LOCAL statement_timeout = '600s';

    TRUNCATE TABLE public.data_summary;
    
    -- Inserção OTIMIZADA: Já calcula se houve positivação e contagem de mix
    INSERT INTO public.data_summary (
        ano, mes, filial, cidade, superv, nome, codfor, tipovenda, codcli, 
        vlvenda, peso, bonificacao, devolucao, 
        mix_produtos, mix_details,
        pre_mix_count, pre_positivacao_val
    )
    WITH raw_data AS (
        SELECT dtped, filial, cidade, superv, nome, codfor, tipovenda, codcli, vlvenda, totpesoliq, vlbonific, vldevolucao, produto 
        FROM public.data_detailed
        UNION ALL
        SELECT dtped, filial, cidade, superv, nome, codfor, tipovenda, codcli, vlvenda, totpesoliq, vlbonific, vldevolucao, produto 
        FROM public.data_history
    ),
    augmented_data AS (
        SELECT 
            EXTRACT(YEAR FROM s.dtped)::int as ano,
            EXTRACT(MONTH FROM s.dtped)::int as mes,
            s.filial, 
            COALESCE(s.cidade, c.cidade) as cidade, 
            s.superv, 
            COALESCE(s.nome, c.nomecliente) as nome, 
            s.codfor, 
            s.tipovenda, 
            s.codcli,
            s.vlvenda, s.totpesoliq, s.vlbonific, s.vldevolucao, s.produto
        FROM raw_data s
        LEFT JOIN public.data_clients c ON s.codcli = c.codigo_cliente
    ),
    product_agg AS (
        SELECT 
            ano, mes, filial, cidade, superv, nome, codfor, tipovenda, codcli, produto,
            SUM(vlvenda) as prod_val,
            SUM(totpesoliq) as prod_peso,
            SUM(vlbonific) as prod_bonific,
            SUM(COALESCE(vldevolucao, 0)) as prod_devol
        FROM augmented_data
        GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
    ),
    client_agg AS (
        SELECT 
            pa.ano, pa.mes, pa.filial, pa.cidade, pa.superv, pa.nome, pa.codfor, pa.tipovenda, pa.codcli,
            SUM(pa.prod_val) as total_val,
            SUM(pa.prod_peso) as total_peso,
            SUM(pa.prod_bonific) as total_bonific,
            SUM(pa.prod_devol) as total_devol,
            ARRAY_AGG(DISTINCT pa.produto) FILTER (WHERE pa.produto IS NOT NULL) as arr_prod,
            jsonb_object_agg(pa.produto, pa.prod_val) FILTER (WHERE pa.produto IS NOT NULL) as json_prod
        FROM product_agg pa
        GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9
    )
    SELECT 
        ano, mes, filial, cidade, superv, nome, codfor, tipovenda, codcli,
        total_val, total_peso, total_bonific, total_devol,
        arr_prod, json_prod,
        -- CÁLCULOS PRÉVIOS AQUI:
        (SELECT COUNT(*) FROM jsonb_each_text(json_prod) WHERE (value)::numeric >= 1 AND codfor IN ('707', '708')) as mix_calc,
        CASE WHEN total_val >= 1 THEN 1 ELSE 0 END as pos_calc
    FROM client_agg;
    
    CLUSTER public.data_summary USING idx_summary_ano_mes_filial;
    ANALYZE public.data_summary;
END;
$$;
Passo 3: Otimizar a leitura (get_main_dashboard_data)
Agora a função de leitura será reescrita para usar SECURITY DEFINER (bypass de RLS) e ler as colunas simples (pre_mix_count) em vez de calcular JSON complexo.

Atenção: Como usamos SECURITY DEFINER, esta função terá poderes de admin. Certifique-se de que os filtros (que já existem na sua lógica) estão sendo aplicados.

SQL

CREATE OR REPLACE FUNCTION get_main_dashboard_data(
    p_filial text[] default null,
    p_cidade text[] default null,
    p_supervisor text[] default null,
    p_vendedor text[] default null,
    p_fornecedor text[] default null,
    p_ano text default null,
    p_mes text default null,
    p_tipovenda text[] default null
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER -- <<< MUDANÇA CRÍTICA: Executa como criador da função (Admin) para pular verificação RLS linha-a-linha
SET search_path = public -- Segurança
AS $$
DECLARE
    v_current_year int;
    v_previous_year int;
    v_target_month int;
    
    -- Trend Vars
    v_max_sale_date date;
    v_trend_allowed boolean;
    v_work_days_passed int;
    v_work_days_total int;
    v_trend_factor numeric := 0;
    v_trend_data json;
    v_month_start date;
    v_month_end date;
    v_holidays json;
    
    -- Dynamic SQL
    v_sql text;
    v_where_clause text := '';
    v_result json;
    
    -- Execution Context
    v_kpi_clients_attended int;
    v_kpi_clients_base int;
    v_monthly_chart_current json;
    v_monthly_chart_previous json;
    v_curr_month_idx int;
BEGIN
    -- Configurações de Memória para esta Query Específica
    SET LOCAL work_mem = '64MB'; -- Aumenta memória para ordenação
    SET LOCAL statement_timeout = '15s'; -- Fail fast se travar

    -- 1. Determine Date Ranges
    IF p_ano IS NULL OR p_ano = 'todos' OR p_ano = '' THEN
        SELECT COALESCE(MAX(ano), EXTRACT(YEAR FROM CURRENT_DATE)::int) INTO v_current_year FROM public.data_summary;
    ELSE
        v_current_year := p_ano::int;
    END IF;
    v_previous_year := v_current_year - 1;

    IF p_mes IS NOT NULL AND p_mes != '' AND p_mes != 'todos' THEN
        v_target_month := p_mes::int + 1;
    ELSE
         SELECT COALESCE(MAX(mes), 12) INTO v_target_month FROM public.data_summary WHERE ano = v_current_year;
    END IF;

    -- 2. Trend Logic Calculation (Mantida igual)
    SELECT MAX(dtped)::date INTO v_max_sale_date FROM public.data_detailed;
    IF v_max_sale_date IS NULL THEN v_max_sale_date := CURRENT_DATE; END IF;

    v_trend_allowed := (v_current_year = EXTRACT(YEAR FROM v_max_sale_date)::int);
    
    IF p_mes IS NOT NULL AND p_mes != '' AND p_mes != 'todos' THEN
       IF (p_mes::int + 1) != EXTRACT(MONTH FROM v_max_sale_date)::int THEN
           v_trend_allowed := false;
       END IF;
    END IF;

    IF v_trend_allowed THEN
        v_month_start := make_date(v_current_year, EXTRACT(MONTH FROM v_max_sale_date)::int, 1);
        v_month_end := (v_month_start + interval '1 month' - interval '1 day')::date;
        IF v_max_sale_date > v_month_end THEN v_max_sale_date := v_month_end; END IF;
        
        v_work_days_passed := public.calc_working_days(v_month_start, v_max_sale_date);
        v_work_days_total := public.calc_working_days(v_month_start, v_month_end);
        
        IF v_work_days_passed > 0 AND v_work_days_total > 0 THEN
            v_trend_factor := v_work_days_total::numeric / v_work_days_passed::numeric;
        ELSE
            v_trend_factor := 1;
        END IF;
    END IF;

    -- 3. Construct Dynamic WHERE Clause
    -- Importante: Como usamos SECURITY DEFINER, verifique se a lógica de usuário aprovado se aplica aqui se necessário
    -- Mas como os filtros vêm do frontend, assumimos que a UI já restringiu o que o user pode pedir
    
    v_where_clause := 'WHERE ano IN ($1, $2) ';
    
    IF p_filial IS NOT NULL AND array_length(p_filial, 1) > 0 THEN
        v_where_clause := v_where_clause || ' AND filial = ANY($3) ';
    END IF;
    IF p_cidade IS NOT NULL AND array_length(p_cidade, 1) > 0 THEN
        v_where_clause := v_where_clause || ' AND cidade = ANY($4) ';
    END IF;
    IF p_supervisor IS NOT NULL AND array_length(p_supervisor, 1) > 0 THEN
        v_where_clause := v_where_clause || ' AND superv = ANY($5) ';
    END IF;
    IF p_vendedor IS NOT NULL AND array_length(p_vendedor, 1) > 0 THEN
        v_where_clause := v_where_clause || ' AND nome = ANY($6) ';
    END IF;
    IF p_fornecedor IS NOT NULL AND array_length(p_fornecedor, 1) > 0 THEN
        v_where_clause := v_where_clause || ' AND codfor = ANY($7) ';
    END IF;
    IF p_tipovenda IS NOT NULL AND array_length(p_tipovenda, 1) > 0 THEN
        v_where_clause := v_where_clause || ' AND tipovenda = ANY($8) ';
    END IF;

    -- 4. Execute Main Aggregation Query (VERSÃO OTIMIZADA)
    -- Removemos todas as subqueries complexas (mix_raw_data, monthly_mix_stats, etc)
    v_sql := '
    WITH filtered_summary AS (
        SELECT 
            ano, mes, codcli, vlvenda, peso, bonificacao, devolucao, tipovenda, pre_mix_count, pre_positivacao_val
        FROM public.data_summary
        ' || v_where_clause || '
    ),
    agg_data AS (
        SELECT
            ano,
            mes,
            -- Agregação simples e direta
            SUM(CASE 
                WHEN ($8 IS NOT NULL AND array_length($8, 1) > 0) THEN vlvenda
                WHEN tipovenda IN (''1'', ''9'') THEN vlvenda 
                ELSE 0 
            END) as faturamento,
            SUM(peso) as peso,
            SUM(bonificacao) as bonificacao,
            SUM(devolucao) as devolucao,
            -- Positivação usando a coluna pré-calculada
            COUNT(DISTINCT CASE WHEN pre_positivacao_val = 1 THEN codcli END) as positivacao_count,
            -- Mix pré-calculado
            SUM(pre_mix_count) as total_mix_sum,
            COUNT(DISTINCT CASE WHEN pre_mix_count > 0 THEN codcli END) as mix_client_count
        FROM filtered_summary
        GROUP BY 1, 2
    ),
    kpi_active_count AS (
        SELECT COUNT(DISTINCT codcli) as val
        FROM filtered_summary 
        WHERE ano = $1 AND mes = $9 AND pre_positivacao_val = 1
    ),
    kpi_base_count AS (
        SELECT COUNT(*) as val FROM public.data_clients c 
        WHERE c.bloqueio != ''S'' 
        AND ($4 IS NULL OR array_length($4, 1) IS NULL OR c.cidade = ANY($4))
    )
    SELECT
        (SELECT val FROM kpi_active_count),
        (SELECT val FROM kpi_base_count),
        -- Gerar JSON diretamente
        COALESCE(json_agg(json_build_object(
            ''month_index'', a.mes - 1, 
            ''faturamento'', a.faturamento, 
            ''peso'', a.peso, 
            ''bonificacao'', a.bonificacao, 
            ''devolucao'', a.devolucao, 
            ''positivacao'', a.positivacao_count, 
            ''mix_pdv'', CASE WHEN a.mix_client_count > 0 THEN a.total_mix_sum::numeric / a.mix_client_count ELSE 0 END, 
            ''ticket_medio'', CASE WHEN a.positivacao_count > 0 THEN a.faturamento / a.positivacao_count ELSE 0 END
        ) ORDER BY a.mes) FILTER (WHERE a.ano = $1), ''[]''::json),
        
        COALESCE(json_agg(json_build_object(
            ''month_index'', a.mes - 1, 
            ''faturamento'', a.faturamento, 
            ''peso'', a.peso, 
            ''bonificacao'', a.bonificacao, 
            ''devolucao'', a.devolucao, 
            ''positivacao'', a.positivacao_count, 
            ''mix_pdv'', CASE WHEN a.mix_client_count > 0 THEN a.total_mix_sum::numeric / a.mix_client_count ELSE 0 END, 
            ''ticket_medio'', CASE WHEN a.positivacao_count > 0 THEN a.faturamento / a.positivacao_count ELSE 0 END
        ) ORDER BY a.mes) FILTER (WHERE a.ano = $2), ''[]''::json)
    FROM agg_data a
    ';

    EXECUTE v_sql 
    INTO v_kpi_clients_attended, v_kpi_clients_base, v_monthly_chart_current, v_monthly_chart_previous
    USING v_current_year, v_previous_year, p_filial, p_cidade, p_supervisor, p_vendedor, p_fornecedor, p_tipovenda, v_target_month;

    -- 5. Calculate Trend (Lógica mantida, apenas recuperando holidays)
    IF v_trend_allowed THEN
        v_curr_month_idx := EXTRACT(MONTH FROM v_max_sale_date)::int - 1;
        DECLARE v_elem json;
        BEGIN
            FOR v_elem IN SELECT * FROM json_array_elements(v_monthly_chart_current)
            LOOP
                IF (v_elem->>'month_index')::int = v_curr_month_idx THEN
                    v_trend_data := json_build_object(
                        'month_index', v_curr_month_idx,
                        'faturamento', (v_elem->>'faturamento')::numeric * v_trend_factor,
                        'peso', (v_elem->>'peso')::numeric * v_trend_factor,
                        'bonificacao', (v_elem->>'bonificacao')::numeric * v_trend_factor,
                        'devolucao', (v_elem->>'devolucao')::numeric * v_trend_factor,
                        'positivacao', ((v_elem->>'positivacao')::numeric * v_trend_factor)::int,
                        'mix_pdv', (v_elem->>'mix_pdv')::numeric,
                        'ticket_medio', (v_elem->>'ticket_medio')::numeric
                    );
                END IF;
            END LOOP;
        END;
    END IF;

    SELECT json_agg(date) INTO v_holidays FROM public.data_holidays;

    v_result := json_build_object(
        'current_year', v_current_year,
        'previous_year', v_previous_year,
        'target_month_index', v_target_month - 1,
        'kpi_clients_attended', COALESCE(v_kpi_clients_attended, 0),
        'kpi_clients_base', COALESCE(v_kpi_clients_base, 0),
        'monthly_data_current', v_monthly_chart_current,
        'monthly_data_previous', v_monthly_chart_previous,
        'trend_data', v_trend_data,
        'trend_allowed', v_trend_allowed,
        'holidays', COALESCE(v_holidays, '[]'::json)
    );
    RETURN v_result;
END;
$$;
Resumo das Mudanças
Eliminação de JSON em tempo real: A função antiga desconstruía o JSON mix_details milhares de vezes por segundo. A nova função lê uma coluna INT simples (pre_mix_count).

Bypass de RLS: A função antiga checava permissão para cada linha antes de somar. A nova (SECURITY DEFINER) roda como Admin no servidor, lê os dados brutos instantaneamente, e aplica os filtros (WHERE) em bloco.

Complexidade Reduzida: Removemos 3 subqueries (mix_eligible_clients, mix_raw_data, monthly_mix_stats) e consolidamos tudo em uma única passagem pela tabela data_summary.
